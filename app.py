# Smart Irrigation Suggestion System - Streamlit Frontend
# File: app.py

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from irrigation_model import SmartIrrigationModel
import os
from datetime import datetime, timedelta

# Page configuration
st.set_page_config(
    page_title="Smart Irrigation System",
    page_icon="üå±",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #2E8B57;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f8f0;
        padding: 1rem;
        border-radius: 10px;
        border-left: 5px solid #2E8B57;
    }
    .recommendation-box {
        background-color: #e8f5e8;
        padding: 1rem;
        border-radius: 10px;
        margin: 1rem 0;
    }
    .warning-box {
        background-color: #fff3cd;
        padding: 1rem;
        border-radius: 10px;
        border-left: 5px solid #ffc107;
    }
</style>
""", unsafe_allow_html=True)

# Define the file name for the best performing model (Random Forest on Real Data)
# Note: This file must be generated by running the comparative_training method in irrigation_model.py locally.
BEST_MODEL_FILE = 'rf_model_real-world_data_smart_irrigation_datasetcsv.pkl'

@st.cache_resource
def load_model():
    """Load the best performing Random Forest model."""
    model = SmartIrrigationModel()
    
    if os.path.exists(BEST_MODEL_FILE):
        try:
            model.load_model(BEST_MODEL_FILE)
            st.success(f"Model loaded successfully: {BEST_MODEL_FILE.split('_')[0]}")
            return model
        except Exception as e:
            st.error(f"Error loading saved model ({BEST_MODEL_FILE}). Please ensure you run the training script first.")
            st.stop()

    else:
        st.error(f"Model file not found: {BEST_MODEL_FILE}. Please run the training code in 'irrigation_model.py' to generate the required model files first.")
        st.stop()

def create_water_gauge(water_amount):
    """Create a water gauge visualization (units now m¬≥)."""
    fig = go.Figure(go.Indicator(
        mode = "gauge+number",
        value = water_amount,
        domain = {'x': [0, 1], 'y': [0, 1]},
        title = {'text': "Irrigation Amount ($\mathbf{m^3}$)"},
        gauge = {
            'axis': {'range': [None, 800], 'tickvals': [0, 200, 400, 600, 800]},
            'bar': {'color': "darkblue"},
            'steps': [
                {'range': [0, 150], 'color': "lightgray"},
                {'range': [150, 400], 'color': "yellow"},
                {'range': [400, 600], 'color': "orange"},
                {'range': [600, 800], 'color': "red"}
            ],
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': 600
            }
        }
    ))
    
    fig.update_layout(height=300)
    return fig

def create_comparison_chart(current_prediction, crop_type):
    """Create comparison chart with other crops (using illustrative data)"""
    # Illustrative data based on general water needs
    crops = ['Wheat', 'Rice', 'Corn', 'Tomato', 'Potato']
    base_water = [150, 400, 200, 250, 180] 
    
    # Insert current crop's prediction into the list if not already present
    if crop_type not in crops:
        crops.append(crop_type)
        base_water.append(current_prediction)
    else:
        # If the crop is in the list, update its value
        idx = crops.index(crop_type)
        base_water[idx] = current_prediction
        
    # Highlight current crop
    colors = ['#2E8B57' if crop == crop_type else 'lightblue' for crop in crops]
    
    fig = px.bar(
        x=crops, 
        y=base_water,
        title="Predicted Water vs. Base Values (Illustrative)",
        color=crops,
        color_discrete_sequence=colors
    )
    
    fig.update_layout(
        xaxis_title="Crop Type",
        yaxis_title="Water Requirement ($\mathbf{m^3}$)",
        showlegend=False,
        height=400
    )
    
    return fig

def calculate_environmental_impact(water_amount, area=100):
    """Calculate environmental impact metrics (units based on m¬≥)"""
    total_water_liters = water_amount * 1000 # Convert m¬≥ to Liters for impact calculation
    
    # Water conservation compared to traditional methods (assumed 25% savings)
    traditional_water_liters = total_water_liters * 1.25
    water_saved_liters = traditional_water_liters - total_water_liters
    
    # CO2 savings (approximate)
    co2_saved = water_saved_liters * 0.0005 # kg CO2 per liter
    
    return {
        'total_water_m3': water_amount,
        'water_saved_m3': water_saved_liters / 1000,
        'co2_saved': co2_saved,
        'cost_saved': water_saved_liters * 0.0005  # approximate cost per liter
    }

def main():
    # Header
    st.markdown('<h1 class="main-header">üå± Smart Irrigation Suggestion System</h1>', unsafe_allow_html=True)
    st.markdown("**Optimize water usage with AI-powered irrigation recommendations**")
    
    # Load model
    model = load_model()
    
    # Sidebar for inputs
    st.sidebar.header("üåæ Farm Parameters")
    
    # Input form
    with st.sidebar.form("irrigation_form"):
        st.subheader("Crop Information")
        crop_type = st.selectbox(
            "Crop Type",
            ['Tomato', 'Wheat', 'Maize', 'Paddy', 'Rice', 'Cotton', 'Sugarcane', 'Soybean'] # Matching common crop names in the CSV
        )
        
        # NOTE: Growth Stage/Season removed from the primary model input as they were not in the unified feature set, but kept for context.
        soil_type = st.selectbox(
            "Soil Type",
            ['Sandy', 'Silty', 'Clay', 'Loamy', 'Peaty']
        )
        
        st.subheader("Environmental Conditions")
        col1, col2 = st.columns(2)
        
        # IMPORTANT: Feature names now match the REAL dataset's unified names (e.g., temperature_C)
        with col1:
            temperature_C = st.slider("Temperature (¬∞C)", -10, 50, 25)
            humidity_percent = st.slider("Humidity (%)", 0, 100, 60)
            rainfall_mm = st.slider("Recent Rainfall (mm)", 0, 50, 0)
        
        with col2:
            wind_speed_m_s = st.slider("Wind Speed (m/s)", 0, 30, 10)
            soil_moisture_percent = st.slider("Soil Moisture (%)", 0, 100, 40)
            # ph_level is kept for recommendations but removed from core model input
            ph_level = st.slider("Soil pH", 4.0, 9.0, 6.5, 0.1) 
        
        # Dummy inputs for full compatibility with original app logic (though not used in final model predict)
        growth_stage = st.selectbox("Growth Stage (Context)", ['Seedling', 'Vegetative', 'Flowering', 'Maturity'])
        season = st.selectbox("Season (Context)", ['Spring', 'Summer', 'Monsoon', 'Winter'])
        
        area = st.number_input("Farm Area (m¬≤)", min_value=1, max_value=10000, value=100)
        
        submit_button = st.form_submit_button("üîç Get Irrigation Recommendation")
    
    # Main content
    if submit_button:
        # Prepare input data (using real dataset's feature names)
        input_data = {
            'crop_type': crop_type,
            'soil_type': soil_type,
            'temperature_C': float(temperature_C),
            'humidity_%': float(humidity_percent),
            'rainfall_mm': float(rainfall_mm),
            'wind_speed_m_s': float(wind_speed_m_s),
            'soil_moisture_%': float(soil_moisture_percent),
            'ph_level': float(ph_level) # Only for contextual recommendations
        }
        
        try:
            # Prepare data specifically for the model's 'predict' method
            model_input = {
                'crop_type': crop_type,
                'soil_type': soil_type,
                'temperature': float(temperature_C), # Mapped to unified name in model
                'humidity': float(humidity_percent), # Mapped to unified name in model
                'rainfall': float(rainfall_mm),       # Mapped to unified name in model
                'wind_speed': float(wind_speed_m_s),  # Mapped to unified name in model
                'soil_moisture': float(soil_moisture_percent), # Mapped to unified name in model
                # Note: Other features from the app form (season, growth_stage, ph_level) are ignored by the model but used for context/recommendations.
            }
            
            with st.spinner("Calculating optimal irrigation..."):
                prediction = model.predict(model_input)
                # Recommendations logic relies on the specific features used in the original app code
                recommendations, warnings = model.get_recommendations(input_data, prediction)
            
            # Display results
            col1, col2, col3 = st.columns([2, 1, 2])
            
            with col1:
                st.subheader("üíß Irrigation Recommendation")
                
                # Water gauge (using m¬≥ units)
                fig_gauge = create_water_gauge(prediction)
                st.plotly_chart(fig_gauge, use_container_width=True)
                
                # Key metrics
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                metric_col1, metric_col2 = st.columns(2)
                with metric_col1:
                    st.metric("Water per m¬≤", f"{prediction:.2f} m¬≥")
                    # Using area is confusing here since the target is already a volume, assuming m¬≥ applies to the whole area.
                    # Let's show the predicted amount simply
                    st.metric("Predicted Amount", f"{prediction:.0f} m¬≥") 
                with metric_col2:
                    # Logic is now illustrative based on predicted volume
                    irrigation_frequency = "Daily" if prediction > 400 else "Every 2-3 days" if prediction > 150 else "Weekly"
                    st.metric("Frequency", irrigation_frequency)
                    efficiency = min(100, (800 - prediction) / 8) # Illustrative efficiency based on scale
                    st.metric("Water Efficiency", f"{max(40, efficiency):.0f}%")
                st.markdown('</div>', unsafe_allow_html=True)
            
            with col2:
                st.subheader("üéØ Status")
                
                if prediction < 150:
                    status = "üü¢ Low Water Need"
                    color = "#28a745"
                elif prediction < 400:
                    status = "üü° Moderate Water Need"
                    color = "#ffc107"
                elif prediction < 600:
                    status = "üü† High Water Need"
                    color = "#fd7e14"
                else:
                    status = "üî¥ Critical Water Need"
                    color = "#dc3545"
                
                st.markdown(f"""
                <div style="background-color: {color}20; padding: 1rem; border-radius: 10px; text-align: center; border: 2px solid {color};">
                    <h3 style="color: {color}; margin: 0;">{status}</h3>
                </div>
                """, unsafe_allow_html=True)
                
                st.subheader("üå°Ô∏è Conditions")
                st.write(f"**Temperature:** {temperature_C}¬∞C")
                st.write(f"**Humidity:** {humidity_percent}%")
                st.write(f"**Soil Moisture:** {soil_moisture_percent}%")
                st.write(f"**Recent Rainfall:** {rainfall_mm}mm")
            
            with col3:
                st.subheader("üìä Crop Comparison")
                fig_comparison = create_comparison_chart(prediction, crop_type)
                st.plotly_chart(fig_comparison, use_container_width=True)
            
            # Recommendations section
            st.subheader("üí° Smart Recommendations")
            
            rec_col1, rec_col2 = st.columns(2)
            
            with rec_col1:
                st.markdown('<div class="recommendation-box">', unsafe_allow_html=True)
                st.write("**Irrigation Guidelines:**")
                for i, rec in enumerate(recommendations, 1):
                    st.write(f"{i}. {rec}")
                st.markdown('</div>', unsafe_allow_html=True)
            
            with rec_col2:
                # Environmental impact
                impact = calculate_environmental_impact(prediction, area)
                
                st.markdown('<div class="recommendation-box">', unsafe_allow_html=True)
                st.write("**Environmental Impact:**")
                st.write(f"üåä Total predicted water: {impact['total_water_m3']:.0f} m¬≥")
                st.write(f"üíö Water saved vs traditional: {impact['water_saved_m3']:.2f} m¬≥")
                st.write(f"üåç CO‚ÇÇ emissions reduced: {impact['co2_saved']:.2f} kg")
                st.write(f"üí∞ Estimated cost savings: ${impact['cost_saved']:.2f}")
                st.markdown('</div>', unsafe_allow_html=True)
            
            # Weather-based warnings
            warnings = []
            if temperature_C > 35:
                warnings.append("‚ö†Ô∏è Extreme heat detected. Consider shade nets and increase irrigation frequency.")
            if humidity_percent < 30:
                warnings.append("‚ö†Ô∏è Very low humidity. Increase irrigation and consider mulching.")
            if soil_moisture_percent > 80:
                warnings.append("‚ö†Ô∏è Risk of waterlogging. Improve drainage and reduce irrigation.")
            if ph_level < 5.5 or ph_level > 8.0:
                warnings.append("‚ö†Ô∏è Soil pH is outside optimal range. Consider soil treatment.")
            
            if warnings:
                st.subheader("‚ö†Ô∏è Alerts")
                for warning in warnings:
                    st.markdown(f'<div class="warning-box">{warning}</div>', unsafe_allow_html=True)
            
        except Exception as e:
            st.error(f"Error making prediction: {str(e)}")
    
    else:
        # Welcome screen
        st.subheader("üåü Welcome to Smart Irrigation System")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.markdown("""
            ### üéØ Features
            - AI-powered water requirement prediction
            - **Two-Model Comparative Analysis**
            - Crop-specific recommendations
            - Environmental impact analysis
            """)
        
        with col2:
            st.markdown("""
            ### üå± Benefits
            - Optimize water usage
            - Increase crop yields
            - Reduce environmental impact
            - Save costs and resources
            """)
        
        with col3:
            st.markdown("""
            ### üì± How to Use
            1. Select your crop and soil type
            2. Input environmental conditions
            3. Get AI-powered recommendations (in $m^3$)
            4. Follow irrigation guidelines
            """)
        
        st.info(f"üëà Use the sidebar to input your farm parameters and get started! The system is running the **Random Forest** model, proven best on the **Real-World Dataset**.")
    
    # Footer
    st.markdown("---")
    st.markdown("**Smart Irrigation System** | Developed for sustainable agriculture üå±")

if __name__ == "__main__":
    main()
